 AIM
To convert a given infix expression (e.g., A + B * C) to its corresponding postfix expression (e.g., ABC*+) using a stack, following operator precedence and associativity rules.
ALGORITHM – Infix to Postfix (Using Stack)

Input: Infix expression
Output: Postfix expression

Start

Initialize an empty stack

For each character ch in the expression:
a. If ch is operand, append it to postfix output
b. If ch is '(', push to stack
c. If ch is ')', pop until '('
d. If ch is an operator:

While stack not empty AND precedence(top) ≥ precedence(ch),
pop to postfix

Push the operator on stack

After scanning the expression, pop all remaining operators from stack

Output postfix expression

Stop


PROGRAM
 #include <stdio.h>
#include <ctype.h>

#define MAX 100

char stack[MAX];
int top = -1;

void push(char x) {
    stack[++top] = x;
}

char pop() {
    return stack[top--];
}

// Precedence function
int precedence(char x) {
    if (x == '^') return 3;
    if (x == '*' || x == '/') return 2;
    if (x == '+' || x == '-') return 1;
    return 0;
}

int main() {
    char infix[MAX], postfix[MAX];
    int i, j = 0;
    char ch;

    printf("Enter Infix Expression: ");
    scanf("%s", infix);

    for (i = 0; infix[i] != '\0'; i++) {
        ch = infix[i];

        // Operand
        if (isalnum(ch)) {
            postfix[j++] = ch;
        }
        // Left parenthesis
        else if (ch == '(') {
            push(ch);
        }
        // Right parenthesis
        else if (ch == ')') {
            while (top != -1 && stack[top] != '(')
                postfix[j++] = pop();
            pop();  // remove '('
        }
        // Operator
        else {
            while (top != -1 && precedence(stack[top]) >= precedence(ch))
                postfix[j++] = pop();
            push(ch);
        }
    }

    // Pop remaining operators
    while (top != -1)
        postfix[j++] = pop();

    postfix[j] = '\0';

    printf("Postfix Expression: %s\n", postfix);
    return 0;
}

